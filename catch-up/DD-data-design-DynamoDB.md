# DynamoDBデータ設計：ベストプラクティスと実践

> 作成日: 2026/02/03
> **目的**: DynamoDBを使った効率的なデータ設計手法を習得する  
> **前提知識**: [DD-fundamental-DynamoDB.md](./DD-fundamental-DynamoDB.md) - DynamoDBの基礎を理解済み  
> **参考**: [AWS公式: ベストプラクティス](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/best-practices.html)  
> **関連**: [documents/02-2-data-design.md](../documents/02-2-data-design.md) - MyBlogプロジェクトのデータ設計

---

## 1. DynamoDB設計の基本原則

### 1.1 RDBMSとの設計思想の違い

| 観点 | RDBMS | DynamoDB (NoSQL) |
|------|-------|------------------|
| **設計の出発点** | データの構造（エンティティ） | アクセスパターン（クエリ） |
| **正規化** | 重複排除のため正規化 | パフォーマンスのため非正規化 |
| **クエリ** | 後から柔軟にJOIN | 事前定義が必須 |
| **テーブル数** | 多数のテーブルに分割 | 可能な限り単一テーブル |
| **最適化の焦点** | ストレージ効率 | クエリ速度とコスト |

### 1.2 設計プロセス

> The first step in designing your DynamoDB application is to identify the specific query patterns that the system must satisfy.
> 
引用: [Approaching NoSQL Design](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-general-nosql-design.html#bp-general-nosql-design-approach)

まず、3つの基本的なアプリケーションに関するについて理解する必要がある。
1. Data size : そのくらいのデータが保存され、一度にリクエストを受け取るか -> Partirionの方法を決定する指標になる。
2. Data shape : 使用するクエリを基準にデータを設計する
3. Data Velocity : ピーク時のクエリ負荷を事前に把握することでI/O容量を最大限に活用するためのデータパーティション分割方法を決定するのに役立つ



```
1. アクセスパターンの洗い出し
   ↓
2. エンティティ関係図（ER図）の作成
   ↓
3. PK/SK設計（シングルテーブルデザイン検討）
   ↓
4. GSI設計（追加のアクセスパターン対応）
   ↓
5. サンプルデータでの検証
   ↓
6. パフォーマンステストとコスト試算
```

1によって特定のクエリ要件を特定したら、パフォーマンスを管理する一般的な原則に従ってデータを整理できる

### a. 関連するデータは一箇所にまとめる (Keep related data together)

* **概念**: 「Locality of Reference（参照の局所性）」を重視する。RDBMSのようにテーブルを分けるのではなく、1回のクエリで必要な情報をすべて取得できる場所にデータを配置する。
* **MyBlog-AWSへの適用**: 記事本体の `PK` に対して、`SK` を使い分けることで「記事のメタデータ」と「コメント」を同じパーティションに同居させる設計がこれに当たる。

### b. テーブル数は最小限にする (Maintain as few tables as possible)

* **概念**: 1つのテーブルに「反転インデックス（Inverted Indexes）」などを組み合わせることで、複雑な階層構造も1つのテーブルで表現できる。
* **例外**: 膨大な量の時系列データ（ログなど）や、全く異なるアクセスパターンを持つデータセット（例：ユーザー認証情報とブログ記事本文）は、管理やコストの観点から分離を検討する。

### c. ソート順を活用する (Use sort order)

* **概念**: 関連するアイテムを「ソートされる順序」を計算して配置することで、効率的にグループ化し、範囲検索（Query）を行う。
* **MyBlog-AWSへの適用**: `CreatedAt`（作成日）をソートキーに含めることで、特別な処理なしに「最新記事から順に取得」できるのはこの原則を利用している。

### d. クエリを分散させる (Distribute queries)

* **概念**: I/O容量を超えないよう、トラフィックをパーティション全体に均等に分散させる設計を行う。
* **注意点**: ノートにまとめた「ホットパーティション」を避けるための設計だ。特定のPKにアクセスが集中しないよう、カーディナリティ（値のバリエーション）の高い項目をキーに選定する。

### e. グローバルセカンダリインデックスの活用 (Use GSIs)

* **概念**: メインのテーブル構造（PK/SK）では対応できない「別の切り口での検索」を、高速かつ安価に実現するためにGSIを作成する。
* **MyBlog-AWSへの適用**: 「タグ別の一覧表示」や「下書き状態の記事のみの抽出」など、記事ID以外の条件で高速に検索したい場合に明示的に定義する。
---

## 2.コスト最適化の話
詳細：[コスト最適化 - AWS デベロッパーガイド](https://docs.aws.amazon.com/ja_jp/amazondynamodb/latest/developerguide/bp-cost-optimization.html)

### 利用可能なテーブルキャパシティモード

DynamoDBのキャパシティ管理における2つのモード、**オンデマンド（On-Demand）** と **プロビジョンド（Provisioned）** の違いについて解説する。

ノートに記載した「1CU = 1秒間に1KBのR/W」という定義が、コストとパフォーマンスにどう反映されるかを理解する上で不可欠な概念だ。


####  2.1. オンデマンドモード (On-Demand)

リクエストがあった分だけ料金を支払う「完全従量課金」モデル。

**特徴**:
* **予測不要**: 事前にRCU/WCUの値を設定する必要がない。
* **即時スケール**: トラフィックの急増（スパイク）に対して、DynamoDBが自動でキャパシティを調整する。


**メリット**:
* アクセス数が予測できない、または変動が激しい場合に適している。
* 「MyBlog-AWS」の初期段階のように、いつ誰が見に来るか分からない状況に最適だ。


**コスト**:
* 100万リクエスト単位での課金。単価はプロビジョンドよりも高めに設定されている。



####  2.2. プロビジョンドモード (Provisioned)

「1秒間に何回の読み書きを行うか」を事前に予約しておくモデル。

**特徴**:
* **RCU/WCUの指定**: 自分でキャパシティの値を設定する（例：5 RCU, 5 WCU）。
* **Auto Scaling**: 指定した範囲内で、負荷に応じて自動増減させる設定も可能。


**メリット**:
* トラフィックが安定している場合、オンデマンドよりも**大幅にコストを抑えられる**。
* 無料利用枠（Free Tier）が適用されるのはこちらのモードである。


**コスト**:
* 実際にリクエストがあったかどうかに関わらず、予約したキャパシティに対して「時間単位」で課金される。


#### 2.3. どちらを選ぶべきか？

| 比較項目 | オンデマンド | プロビジョンド |
| --- | --- | --- |
| **運用の手間** | ほぼゼロ。おまかせ。 | トラフィック予測と設定が必要。 |
| **スループット** | リクエストに応じて無限にスケール。 | 設定値（予約分）まで。超えるとエラー。 |
| **コスト構造** | 使った分だけ（単価高め）。 | 予約枠（単価安め）。 |
| **適したフェーズ** | 開発初期、予測不能なバースト。 | 本番運用、安定したトラフィック。 |


####  2.4. 本プロジェクトでは... (あとで移動する)

あなたのプロジェクトにおける方針を提案する。

* **開発・初期運用**: **プロビジョンドモード（Auto Scalingなし、最小値5）** を推奨する。
* **理由**: AWS無料利用枠を活用できるため、コストを  に抑えて学習を継続できるからだ。


* **アイルランド移住後、記事がバズった時**: **オンデマンドモード** への切り替えを検討する。
* **理由**: 世界中からのアクセススパイク（ホットパーティション気味のアクセス）に対しても、管理の手間なく安定してミリ秒単位の応答を維持できるからだ。
---

## 3. Partition Key の設計
Amazon DynamoDB テーブルの各項目を一意に識別する主キーは、
- シンプル (パーティションキーのみ)
- 複合 (パーティションキーとソートキーの組み合わせ) 

で構成できる。

**そもそもPartitionとは？**
> 巨大なデータを管理しやすくするために分割された、物理的なストレージ（サーバー）の単位

物理配置の決定: パーティションキー（PK）を設定すると、ハッシュ計算によってデータが保存される**物理的なサーバー（パーティション）** が決定する。

水平スケーリングの仕組み: データを複数のパーティションに分散配置することで、データ量が増えても並列処理による高いパフォーマンスを維持できる。

「ホットパーティション」の回避: 特定のPKにアクセスが集中すると、特定の物理サーバーに負荷が偏り、処理制限（スロットリング）が発生する。

**適切なPK設計の重要性: アクセスを分散させるために、値のバリエーション（カーディナリティ）が多い属性をPKに選定することが不可欠である。**

パーティションキーを分散するための1つの手段として[Sharding](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-sharding.html)があるが、本プロジェクトでは記事ID(UUID)を使用する予定であるため、この問題には遭遇しないと思われる


## 4. Sort Keyの設計

ソートキーの最大の利点は、**物理的に近い場所にデータを集め、効率的に取り出せる**ことにある。

* **効率的なグループ化**: PKで場所を特定し、SKで関連するアイテムをひとまとめにする。これにより、特定の範囲だけを高速に取得できる。
* **柔軟な演算子**: `begins_with`（前方一致）や `between`（範囲指定）などを使って、必要なグループだけをピンポイントで狙い撃ちできる。

### 4.1.  複合ソートキーによる階層構造の表現

「国 # 地域 # 州 # 市」のように、データを `#` で繋いでSKに格納する設計パターンだ。

* **1対多の階層検索**: `begins_with(Japan#Kanto)` とクエリを投げれば、関東地方の全データを一括取得できる。
* **任意のレベルで集計**: 検索条件を変えるだけで、国単位から町内会単位まで、どの階層レベルでも効率的なクエリが可能になる。


###  4.2. ソートキーによるバージョン管理（v0 設計パターン）

履歴（変更ログ）を残しつつ、「最新版」を常に最速で取得するための非常に賢いパターンだ。

### 仕組み

1. **最新版（v0）**: 最新のデータには常に `v0_Audit` のような固定のプレフィックスを付けて保存する。
2. **履歴版（v1, v2...）**: 更新のたびに、`v1_`, `v2_` と数値をインクリメントした履歴アイテムを新規作成する。
3. **同期処理**: 新しい履歴を作ると同時に、その内容で `v0` のアイテムを上書き更新する。

**メリット**

* **最新版の即時取得**: バージョン番号を計算したり全件検索したりせずとも、`SK = v0_Audit` を指定するだけで常に最新版が手に入る。
* **全履歴の参照**: 特定のPKに対してクエリを投げ、`v0` 以外をフィルタリングすれば、過去の全履歴を時系列で取得できる。

## 5. Secondary indexes

主キー（PK/SK）以外の属性で高速な検索を実現するための「追加の索引」である。DynamoDBには2種類のセカンダリインデックスが存在する。

### 5.1 GSI vs LSI の比較と選択基準

| 特徴 | グローバルセカンダリインデックス (GSI) | ローカルセカンダリインデックス (LSI) |
| --- | --- | --- |
| **キー構成** | テーブルとは異なる PK および SK を設定可能。 | テーブルと同じ PK だが、異なる SK を設定する。 |
| **スループット** | テーブルとは独立して設定。コスト管理がしやすい。 | テーブルの RCU/WCU を共有する。 |
| **制約** | サイズ制限なし。作成後も削除可能。 | アイテムコレクション（1つのPKあたりのデータ）が10GB以内。 |
| **推奨用途** | **基本的にはこちらを優先**。柔軟性が高く運用リスクが低い。 | 強い整合性（Strongly Consistent Read）が必須の特殊なクエリのみ。 |

### 5.2 射影（Projection）による最適化

インデックスには、ベーステーブルからどの属性をコピーするかを選択できる。インデックスを小さく保つことがコストとパフォーマンスの両立に不可欠である。

* **KEYS_ONLY**: 主キーのみを投影。インデックスサイズは最小だが、非キー属性が必要な場合にテーブルへの「フェッチ（Fetch）」が発生し、遅延とコストが増大する。
* **INCLUDE**: クエリに必要な特定の属性（例：記事タイトル、日付）だけを指定して投影。**実務において最も推奨される設定**。
* **ALL**: 全属性を投影。インデックスだけでクエリが完結するため最速だが、書き込みコストとストレージ費用がほぼ倍増する。

### 5.3 設計のガイドライン

1. **インデックスの数を最小限に抑える**: 頻繁に検索しない属性にインデックスを貼らない。書き込み負荷（WCU消費）を増大させ、パフォーマンスを低下させる原因になる。
2. **フェッチ（Fetch）を避ける**: 高頻度で実行するクエリについては、必要な属性をすべてインデックスに投影し、ベーステーブルへの追加アクセスを回避する。
3. **LSIの削除不可に注意**: LSIはテーブル作成時にしか定義できず、後から削除もできない。設計ミスが許されないため、まずはGSIでの代用を検討する。
