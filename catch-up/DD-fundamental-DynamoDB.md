# DynamoDB基礎知識：技術的特性と仕組み

> **目的**: DynamoDBの技術的な仕組みと基本概念を理解する  
> **対象者**: DynamoDBを初めて学ぶ開発者  
> **関連文書**: [DD-data-design-DynamoDB.md](./DD-data-design-DynamoDB.md) - データ設計のベストプラクティス

---

## 1. DynamoDB とは

DynamoDBは、**OLTP (Online Transaction Processing)** に最適化されたフルマネージドなNoSQLデータベースサービスである。

### 1.1 OLTP の定義

リアルタイムで大量のトランザクションを高速に処理する仕組み。

**具体例**:
- 銀行のATM取引
- ECサイトの決済処理
- ブログの記事閲覧
- SNSのタイムライン取得

### 1.2 主な特徴

| 特徴 | 説明 |
|------|------|
| **一貫したパフォーマンス** | データ量に関わらず、1ミリ秒未満の応答時間を実現 |
| **無制限のスケーラビリティ** | スループットとストレージに実質的な上限なし |
| **高可用性** | 最大99.999%のSLA、マルチAZレプリケーション |
| **フルマネージド** | サーバー管理不要、自動バックアップ・復旧 |
| **サーバーレス統合** | Lambda等のAWSサービスとシームレスに連携 |

---

## 2. RDBMS との技術的な違い

### 2.1 パフォーマンスの根拠：アルゴリズムの違い

データ探索の計算量の違いが、大規模環境でのパフォーマンス差を生む。

#### RDBMS (B-tree Index)

```
計算量: O(log n)
```

- 二分探索木ベースのインデックス構造
- データ量 n が増加すると、インデックスの階層が深くなる
- 百万件→千万件でわずかに応答時間が増加

**例**: 100万件のデータで10階層、1000万件で13階層

#### DynamoDB (Hash Index)

```
計算量: O(1)
```

- パーティションキー（PK）をハッシュ関数で計算
- 物理的なパーティション位置を一瞬で特定
- データ量に依存せず、常に一定のパフォーマンス

**例**: 1件でも1億件でも、PK指定のクエリは同じ速度

### 2.2 スケーリング戦略の違い

| 項目 | RDBMS | DynamoDB |
|------|-------|----------|
| **スケーリング方式** | 垂直スケール (Scale-up) | 水平スケール (Scale-out) |
| **拡張方法** | より高性能なサーバーへ交換 | サーバー台数を増やして分散 |
| **コスト特性** | 高性能サーバーは指数関数的に高価 | リニアなコスト増加 |
| **性能上限** | ハードウェア限界あり | 実質的に無制限 |
| **運用負荷** | 手動での容量計画が必要 | 自動スケーリング対応 |

### 2.3 データ配置の違い

**RDBMS**:
- テーブルを正規化して保存
- JOIN操作で複数テーブルを結合
- 柔軟な検索が可能だが、JOIN はコストが高い

**DynamoDB**:
- アイテムはPKのハッシュ値で決定されたパーティションに配置
- 同一パーティション内でSKの順にソート
- JOIN不可、事前にアクセスパターンを設計

---

## 3. DynamoDB の核となる概念

### 3.1 テーブル構造

```
テーブル
  └── アイテム (Item) ≈ RDBMSの行
      └── 属性 (Attribute) ≈ RDBMSの列
```

### 3.2 キー構造

#### プライマリキー (Primary Key)

**パターン1: シンプルプライマリキー**
```
PK のみ
例: articleId
```

**パターン2: コンポジットプライマリキー**
```
PK + SK (Sort Key)
例: userId (PK) + createdAt (SK)
```

#### セカンダリインデックス

**GSI (Global Secondary Index)**:
- テーブル全体に対する別のビュー
- 異なるPK/SKでクエリ可能
- 独自のキャパシティユニットを消費

**LSI (Local Secondary Index)**:
- 同じPKで異なるSKを使用
- テーブル作成時のみ定義可能（後から追加不可）
- テーブルのキャパシティを共有

---

## 4. キャパシティユニット

DynamoDBの性能とコストの基本単位。

### 4.1 WCU (Write Capacity Unit)

```
1 WCU = 最大 1 KB の項目を 1 秒間に 1 回書き込む能力
```

**計算例**:
- 5 KB のアイテムを書き込む → 5 WCU
- 1 秒間に 10 回書き込む → 10 WCU
- 5 KB × 10 回/秒 → 50 WCU

### 4.2 RCU (Read Capacity Unit)

```
1 RCU = 最大 4 KB の項目を 1 秒間に 1 回読み取る能力
（強力な整合性読み取りの場合）
```

**計算例**:
- 8 KB のアイテムを読み取る → 2 RCU
- 結果整合性の場合 → 1 RCU（半分）

### 4.3 キャパシティモード

| モード | 説明 | 適用ケース |
|--------|------|------------|
| **オンデマンド** | 従量課金、自動スケーリング | トラフィックが予測不可能な場合 |
| **プロビジョンド** | 事前にWCU/RCUを設定 | 安定したトラフィック、コスト最適化 |

---

## 5. 整合性モデル (Consistency Models)

DynamoDBは複数のAZ（可用性ゾーン）にデータをレプリケートする。読み取り時にどのレプリカから読むかを選択できる。

### 5.1 結果整合性 (Eventually Consistent) - デフォルト

**特性**:
- 書き込み直後の読み取りで、最新データが返らない可能性
- 通常1秒以内に全レプリカに反映
- 消費RCUが半分（コスト効率◎）

**用途**:
- ブログ記事の閲覧
- 商品一覧の表示
- タイムライン表示

**例**:
```
時刻 0:00 - 記事を公開（status: PUBLISHED）
時刻 0:01 - ユーザーAが閲覧 → まだ下書き表示の可能性（低確率）
時刻 0:02 - ユーザーBが閲覧 → 公開済みとして表示（ほぼ確実）
```

### 5.2 強力な整合性 (Strongly Consistent)

**特性**:
- 書き込み完了後、即座に最新データを保証
- 消費RCUが2倍
- わずかにレイテンシー増加

**用途**:
- 管理画面での記事更新直後の確認
- 在庫管理（二重購入防止）
- 決済処理

**例**:
```
時刻 0:00 - 記事を公開（status: PUBLISHED）
時刻 0:01 - 管理画面で確認 → 必ず公開済みとして表示
```

### 5.3 選択基準

```python
# 結果整合性（デフォルト）
response = table.get_item(
    Key={'articleId': '123'}
)

# 強力な整合性
response = table.get_item(
    Key={'articleId': '123'},
    ConsistentRead=True  # RCU 2倍消費
)
```

---

## 6. パーティショニングの仕組み

### 6.1 パーティションとは

DynamoDBはデータを複数の物理サーバー（パーティション）に分散して保存する。

```
テーブル
  ├── パーティション A (PK: article#001 ~ article#500)
  ├── パーティション B (PK: article#501 ~ article#999)
  └── パーティション C (PK: category#*, user#*)
```

### 6.2 パーティション分割のロジック

1. PKの値をハッシュ関数で計算
2. ハッシュ値に基づいてパーティションを決定
3. 各パーティションに均等にデータを分散

### 6.3 ホットパーティション問題

**問題**: 特定のパーティションにアクセスが集中し、割り当てられたスループットを超過

#### 発生原因

❌ **悪い例**: 低カーディナリティのPK
```
PK: status (DRAFT, PUBLISHED, ARCHIVE の3種類のみ)
→ 3つのパーティションに全データが集中
```

❌ **悪い例**: 超人気記事への集中アクセス
```
article#999 に 1日100万リクエスト
→ 1つのパーティションが過負荷
```

#### 回避策

✅ **良い例**: 高カーディナリティのPK
```
PK: articleId (UUID: 事実上無限の組み合わせ)
→ 自然に全パーティションへ分散
```

✅ **良い例**: Write Sharding（書き込みシャーディング）
```
PK: articleId + ランダムサフィックス (1-10)
例: article#999#1, article#999#2, ..., article#999#10
→ 同じ記事を10パーティションに分散
```

---

## 7. TTL (Time to Live) - 自動削除機能

### 7.1 仕組み

TTLは、データの有効期限を指定し、期限切れアイテムをDynamoDBが自動削除する機能。

**設定方法**:
1. Unixタイムスタンプ形式の属性を用意
2. テーブル設定でTTL属性を指定
3. DynamoDBがバックグラウンドで定期的にスキャン＆削除

**重要な特性**:
- 削除はベストエフォート（最大48時間の遅延あり）
- WCUを消費しない（無料）
- 削除されたアイテムはDynamoDB Streamsに記録される

### 7.2 実装例

```python
import time

# 1週間後に自動削除される記事
item = {
    'articleId': 'temp-001',
    'title': '期間限定キャンペーン',
    'ttl': int(time.time()) + (7 * 24 * 60 * 60)  # 現在時刻 + 7日
}

table.put_item(Item=item)
```

### 7.3 メリット

| メリット | 説明 |
|----------|------|
| **コスト削減** | 不要データを自動排除、ストレージ料金を抑制 |
| **運用負荷軽減** | 削除バッチ処理を自前実装する必要なし |
| **コンプライアンス** | 個人情報の保持期間を自動管理 |

### 7.4 用途例

- 期間限定キャンペーン記事の自動アーカイブ
- セッション情報の自動削除（30分後）
- 1年経過したアクセスログの自動破棄
- 一時的な招待トークン（24時間有効）

---

## 8. 補足：DynamoDB設計の制約

### 8.1 できること

✅ PK（およびSK）を指定した超高速検索  
✅ GSI/LSIを使った代替キーでの検索  
✅ 結果整合性による低コスト読み取り  
✅ トランザクション処理（最大25アイテム）  
✅ 無制限の水平スケーリング  

### 8.2 できないこと / 非推奨

❌ JOIN操作（複数テーブルの結合）  
❌ 柔軟なフィルタリング（事前定義が必須）  
❌ 全件走査（Scan）の頻繁な使用（遅い＆高コスト）  
❌ 複雑な集計クエリ（SUM, AVG等）  
❌ PKなしの自由な検索  

**設計の鉄則**: 
> 「どのようなクエリを投げるか」を事前に明確にし、それに最適化したスキーマを設計する

---

## 9. まとめ

| 項目 | 重要ポイント |
|------|--------------|
| **パフォーマンス** | O(1)のハッシュインデックスで一貫した速度 |
| **スケーリング** | 水平スケールで無制限に拡張可能 |
| **キャパシティ** | WCU/RCUの理解がコスト最適化の鍵 |
| **整合性** | 用途に応じて結果整合性/強力な整合性を使い分け |
| **パーティショニング** | 高カーディナリティのPKでホットパーティションを回避 |
| **TTL** | 自動削除でストレージコストとコンプライアンスを両立 |
| **設計思想** | アクセスパターン駆動のスキーマ設計が必須 |

---

## 次のステップ

✅ DynamoDBの基本を理解した  
→ 次は [DD-data-design-DynamoDB.md](./DD-data-design-DynamoDB.md) で実践的なデータ設計のベストプラクティスを学ぶ

**推奨読み物**:
- [AWS公式: DynamoDB開発者ガイド](https://docs.aws.amazon.com/dynamodb/)
- [AWS公式: ベストプラクティス](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/best-practices.html)
