# Data Design

## 1.アクセスパターンの洗い出し

### 自分で考えてみる
**一般ユーザー**
1. 記事一覧を取得する (投稿日順にソート)
2. 記事詳細ページへのアクセスをする(詳細データを取得する)
3. キーワードで検索する(タイトルや記事の内容に検索する文字列が含まれているかどうか)
4. タグで表示を絞る
5. 「About」ページでユーザー(管理者)の情報を取得する
6. 「Contact」ページから問い合わせをする

**管理者**
1. ユーザー(管理者を作成する)
2. ユーザーの認証を行う
3. 記事の一覧を取得する
4. 記事詳細を取得する
5. 記事の新規作成を行う
6. 既存記事の編集をする
5. 既存記事の削除をする

### AIからのFB
洗い出したアクセスパターンは、ブログシステムの基本機能を網羅できていて非常に良い。ただ、DynamoDBの「設計（PK/SK/GSIの決定）」に落とし込む際に、もう少し具体的にしておかないと後で困るポイントがいくつかある。

特に**「ステータス（公開・下書き）」**と**「検索の仕組み」**について補足が必要だ。

---

#### 修正・追加すべきアクセスパターン

##### 1. 「公開ステータス」の区別（重要）

一般ユーザーと管理者では、見えて良い記事が異なる。

* **一般ユーザー**: **「公開済み（Published）」** の記事のみを取得する。
* **管理者**: **「下書き（Draft）」** を含む全記事を取得する。
* *設計への影響*: これを考慮しないと、一般ユーザーに下書き記事が漏洩するリスクがある。

##### 2. 「キーワード検索」の実現方法

* **現状**: 「タイトルや内容に文字列が含まれているか」の検索。
    * **DynamoDBの制約**: 実はDynamoDB単体では、部分一致（中間一致）検索は非常に苦手だ（Scanが発生し、コストが跳ね上がる）。
* **対策の検討**:
    * 検索対象を「タグ」や「カテゴリ」に限定して GSI で引く。
    * あるいは、全文検索エンジン（Amazon OpenSearch等）を別途検討するか、件数が少なければ割り切る必要がある。

参考：[DynamoDB GSIの使い方を簡潔に解説](https://qiita.com/NaoyaOshiro/items/d2e520ee23476f477bb2)


##### 3. 「Aboutページ」のデータ取得

* **詳細**: 管理者のプロフィール（名前、経歴、SNSリンクなど）をどこに置くか。
* **設計のヒント**: これもブログ記事と同じテーブルに入れる「シングルテーブルデザイン」にするのか、別テーブルにするのかを検討する項目だ。


#### ブラッシュアップしたアクセスパターン案

以下の項目をリストに加えると、DynamoDBの物理設計（PK/SKの割り当て）がスムーズに進む。

### 一般ユーザー

1. **最新の「公開済み」記事一覧**を、投稿日順（降順）で取得する。
2. **特定のタグ**が付いた「公開済み」記事一覧を、投稿日順で取得する。
3. **特定の記事ID**の詳細データ（本文、メタデータ）を取得する。
4. 管理者の**最新のプロフィール**情報を取得する。 -> これは管理者の情報をハードコーディングしてしまって良さそう
5. 問い合わせ内容を**新規登録（書き込み）** する。 -> DBに蓄積しなくてもメール配信の履歴が残るのと、おそらく問い合わせは滅多にないので、他のAWSサービスで(DB使わなくても)事足りる

### 管理者

1. **全ステータス（公開/下書き）** の記事一覧を、更新日順で取得する。
2. 「下書き」状態の記事のみをリストアップする。
3. 新しい記事を**作成**、または既存の記事を**更新・削除**する。
4. ユーザー認証のために、**特定のユーザー名**に紐づく認証情報を取得する。


ここまでの議論で洗練された、将来的なレイアウト拡張性や認証の外部化（Cognito利用）を含む最新のデータ設計ドキュメントだ。

---

## 2. エンティティ関係図 (ER図)

本プロジェクトでは、認証基盤を **Amazon Cognito** に集約するため、DynamoDB内にはビジネスロジックに直結するコンテンツ系のエンティティのみを配置する。

### 2.1 エンティティ定義

* **Post (ブログ記事)**: 記事の基本情報（タイトル、概要、公開ステータス、日付等）を保持する。
* **ContentBlock (記事構成ブロック)**: 記事の本文を構成する最小単位。テキスト、画像URLなどを保持し、レイアウト情報の属性も持つ。
* **Tag (タグ)**: 記事の分類属性。記事の検索・フィルタリングに使用する。

### 2.2 リレーションシップの詳細

1. **Post と ContentBlock (1:N)**
* **関係**: 1つの記事（Post）は、複数のブロック（ContentBlock）によって構成される。
* **設計方針**: シングルテーブルデザインに基づき、同一のパーティションキー（PK）を共有させる。これにより、記事詳細アクセス時の「一括取得」を最適化する。


2. **Post と Tag (N:M)**
* **関係**: 1つの記事は複数のタグを持ち、1つのタグは複数の記事に付与される。
* **設計方針**: **隣接リスト形式（Adjacency List）**を採用。
* **実装**: ベーステーブルに `POST#ID` と `TAG#Name` のペアを保存し、GSI（グローバルセカンダリインデックス）で反転させることで、タグからの逆引き検索を高速化する。



## 3. 物理設計（PK/SK）へのマッピング案

ER図の関係性を踏まえ、以下のようなプレフィックスを用いたキー設計を行う。

| エンティティ | PK (Partition Key) | SK (Sort Key) | 主な属性 (Attributes) |
| --- | --- | --- | --- |
| **Post (メタデータ)** | `POST#<PostID>` | `METADATA` | `title`, `status`, `createdAt`, `updatedAt`, `thumbnail` |
| **ContentBlock** | `POST#<PostID>` | `BLOCK#<Order>` | `type`, `content`, `layout` (`full`, `half_left`, `half_right`) |
| **Tag (中間データ)** | `POST#<PostID>` | `TAG#<TagName>` | `tagName` |

### 3.1 レイアウトのカスタマイズ性に関する設計

* **多段組対応**: `ContentBlock` に `layout` 属性を持たせる。
* **判断ロジック**: `SK` の `BLOCK#<Order>` によって順序が保証されているため、`half_left` と `half_right` が連続する順序（Order）で並んでいる場合、フロントエンド側で Flexbox 等を用いて 2 段組としてレンダリングする。これにより、不要な `groupId` を持たずとも柔軟なレイアウト制御を可能にする。

### 3.2 インデックス設計 (GSI)

* **GSI1 (汎用逆引きインデックス)**:
* **PK**: `sk` (ベーステーブルのSK)
* **SK**: `pk` (ベーステーブルのPK)
* **目的**: 
  * **タグ検索**: 特定のタグを持つ記事を効率的に検索する（例: `TAG#AWS`）
  * **ステータス検索**: 特定のステータスの記事を効率的に検索する（例: `STATUS#published`, `STATUS#draft`）
* **射影 (Projection)**: `INCLUDE` (`title`, `status`, `createdAt`, `summary`, `thumbnail`)。一覧表示に必要な属性のみを投影し、コストを最適化する。

#### GSI1の使用例

##### 1. タグ検索（一般ユーザー・管理者）
```
Query(GSI1_PK="TAG#AWS")
→ タグ「AWS」が付いた記事一覧を取得
```

##### 2. ステータス検索（主に管理者）
```
Query(GSI1_PK="STATUS#published")
→ 公開済み記事一覧を取得

Query(GSI1_PK="STATUS#draft")
→ 下書き記事一覧を取得（管理者画面）

Query(GSI1_PK="STATUS#archived")
→ アーカイブ記事一覧を取得
```


物理設計のプレフィックスを用いた、具体的なベーステーブルのデータイメージを示す。
この設計により、**「1回のクエリで記事の全情報を取得する」** というDynamoDBのベストプラクティスがどう具現化されるかが明確になる。

### ベーステーブルのデータレイアウト例

例えば、PostIDが `p123` の公開済み記事に、2つの本文ブロック（画像とテキスト）があり、タグが2つ付いている場合のイメージだ。

| PK (Partition Key) | SK (Sort Key) | title / type | content / status | layout | summary |
| --- | --- | --- | --- | --- | --- |
| `POST#p123` | `METADATA` | アイルランド移住記 | `published` | - | アイルランドへの移住体験記 |
| `POST#p123` | `STATUS#published` | アイルランド移住記 | `published` | - | アイルランドへの移住体験記 |
| `POST#p123` | `BLOCK#00001` | `image` | `https://s3.../img.jpg` | `half_left` | - |
| `POST#p123` | `BLOCK#00002` | `text` | ダブリンに到着しました... | `half_right` | - |
| `POST#p123` | `TAG#Ireland` | - | - | - | - |
| `POST#p123` | `TAG#Travel` | - | - | - | - |

**注意点:**
- `STATUS#published` アイテムは、GSI1によるステータス検索を効率化するために追加される
- このアイテムは記事作成時・ステータス変更時に自動的に更新される
- `BLOCK#` のOrderは5桁ゼロ埋め（例: `BLOCK#00001`, `BLOCK#00123`）でソート順を保証

### GSI1のデータレイアウト例

GSI1は、ベーステーブルのPKとSKを反転させた汎用逆引きインデックスだ。
同じ記事（`POST#p123`）が、GSI1ではどのように見えるかを示す。

| PK (GSI1_PK) | SK (GSI1_SK) | title | status | createdAt | summary | thumbnail |
| --- | --- | --- | --- | --- | --- | --- |
| `STATUS#published` | `POST#p123` | アイルランド移住記 | `published` | 2024-01-15T10:00:00Z | アイルランドへの移住体験記 | https://s3.../thumb.jpg |
| `TAG#Ireland` | `POST#p123` | アイルランド移住記 | `published` | 2024-01-15T10:00:00Z | アイルランドへの移住体験記 | https://s3.../thumb.jpg |
| `TAG#Travel` | `POST#p123` | アイルランド移住記 | `published` | 2024-01-15T10:00:00Z | アイルランドへの移住体験記 | https://s3.../thumb.jpg |

**注意点:**
- ベーステーブルの `sk` → GSI1の `pk`（逆引きキー）
- ベーステーブルの `pk` → GSI1の `sk`（記事ID）
- `METADATA` と `BLOCK#xxx` はGSI1に現れない（射影対象外）
- 射影属性（`title`, `status`, `createdAt`, `summary`, `thumbnail`）のみが含まれる

**複数の記事がある場合のGSI1イメージ:**

| PK (GSI1_PK) | SK (GSI1_SK) | title | status | createdAt |
| --- | --- | --- | --- | --- |
| `STATUS#published` | `POST#p123` | アイルランド移住記 | `published` | 2024-01-15T10:00:00Z |
| `STATUS#published` | `POST#p456` | AWS CDK入門 | `published` | 2024-01-20T14:30:00Z |
| `STATUS#published` | `POST#p789` | TypeScript Tips | `published` | 2024-01-25T09:15:00Z |
| `STATUS#draft` | `POST#p124` | 次の記事の下書き | `draft` | 2024-01-26T11:00:00Z |
| `TAG#AWS` | `POST#p456` | AWS CDK入門 | `published` | 2024-01-20T14:30:00Z |
| `TAG#AWS` | `POST#p789` | TypeScript Tips | `published` | 2024-01-25T09:15:00Z |
| `TAG#Ireland` | `POST#p123` | アイルランド移住記 | `published` | 2024-01-15T10:00:00Z |
| `TAG#Travel` | `POST#p123` | アイルランド移住記 | `published` | 2024-01-15T10:00:00Z |
| `TAG#TypeScript` | `POST#p789` | TypeScript Tips | `published` | 2024-01-25T09:15:00Z |

このレイアウトにより、以下のクエリが効率的に実行できる:

```typescript
// 公開済み記事一覧
Query(GSI1_PK="STATUS#published")
→ POST#p123, POST#p456, POST#p789

// 下書き記事一覧（管理者用）
Query(GSI1_PK="STATUS#draft")
→ POST#p124

// タグ「AWS」の記事一覧
Query(GSI1_PK="TAG#AWS")
→ POST#p456, POST#p789
```

#### このレイアウトによるクエリの動作

##### 1. 記事詳細ページを表示するとき

* **実行する操作**: `Query(PK="POST#p123")`
* **結果**: 上記の5行すべてが一度に返ってくる。
* **利点**:
* フロントエンド側で `SK` を見て、`METADATA` ならタイトルを表示し、`BLOCK#` なら本文を表示し、`TAG#` ならタグ一覧を表示、といった処理が **1回のAPIコール** で完結する。
* `BLOCK#001` と `002` の `layout` が `half_...` で連続しているため、横並びの2段組としてレンダリングできる。



##### 2. タグ「Ireland」の記事一覧を表示するとき（GSI1を使用）

* **実行する操作**: `Query(GSI1_PK="TAG#Ireland")` （インデックス側を検索）
* **結果**: `POST#p123` が見つかる。
* **利点**: `TAG#` アイテムがベーステーブルに存在し、それがGSIに投影されているため、タグからの逆引きが  で可能になる。

